{"version":3,"file":"index.module.js","sources":["../src/utils/snake-case.ts","../src/transform-api.ts","../src/utils/is-object.ts","../src/utils/deep-freeze.ts","../src/utils/unfreeze.ts","../src/copy-with.ts","../src/transform-map.ts","../src/from-json.ts","../src/utils/is-null-or-undefined.ts","../src/nullable.ts","../src/make.ts"],"sourcesContent":["export function snakeCase(str: string): string {\n  return str\n    .replace(/\\W+/g, ' ')\n    .split(/ |\\B(?=[A-Z])/)\n    .map((word) => word.toLowerCase())\n    .join('_');\n}\n","import { AllowableKeys, fromJson, JsonResponse, Type } from '.';\nimport { getTransform } from './transform-map';\nimport { Nullable } from './types';\nimport { snakeCase } from './utils/snake-case';\n\nexport type TransformResponse<T> = {\n  [k in AllowableKeys<T>]?: T[k];\n};\n\nexport type Transform<T> = () => T;\n\nexport type TransformerDefinition<T> = (json: JsonResponse, api: TransformAPI) => TransformResponse<T>;\n\nexport interface TransformAPI {\n  /**\n   * Allows for returning null if the value is set to null. Otherwise the the transform method is invoked\n   * and the value is returned.\n   */\n  nullOr: <T>(nullable: Nullable<any>, transform: Transform<T>) => Nullable<T>;\n\n  /**\n   * Allows for returning a default value if the given value is set to null. Otherwise the the transform method is invoked\n   * and the value return from that is returned.\n   */\n  withDefault: <T, D>(nullable: Nullable<any>, transform: Transform<T>, defaultVal: D) => T | D;\n\n  /**\n   * Allows for multiple keys to be passed an converted from whatever casing to snake_case.\n   * This is useful when many of your attributes are returned in something like snake_case.\n   * If keys is omitted, all keys will be read from snake_case json values.\n   *\n   * This is shorthand for doing:\n   *\n   * ```\n   * return {\n   *    userId: json.user_id,\n   *    firstName: json.first_name,\n   *    lastName: json.last_name,\n   * }\n   * ```\n   */\n  fromSnakeCaseKeys<T>(keys?: AllowableKeys<T>[]): TransformResponse<T>;\n}\n\nlet calls = 0;\n\n/**\n * The factory method to create the transform API.\n * This uses currying so we can leverage the current model as part of the context.\n */\nexport function createTransformAPI<T>(model: T, json: JsonResponse): TransformAPI {\n  function nullOr<T>(nullable: Nullable<any>, transform: Transform<T>): Nullable<T> {\n    return withDefault(nullable, transform, null);\n  }\n\n  function withDefault<T, D>(nullable: Nullable<any>, transform: Transform<T>, defaultVal: D): T | D {\n    if (nullable === null || typeof nullable === 'undefined') {\n      return defaultVal;\n    }\n\n    return transform();\n  }\n\n  function fromSnakeCaseKeys<T>(keys?: AllowableKeys<T>[]): TransformResponse<T> {\n    const transforms: TransformResponse<T> = {};\n\n    if (keys) {\n      keys.forEach((key) => {\n        transforms[key as string] = json[snakeCase(key as string)];\n      });\n    } else {\n      const modelKeys = Object.getOwnPropertyNames(model);\n\n      modelKeys.forEach((key) => {\n        transforms[key as string] = json[snakeCase(key as string)];\n      });\n    }\n\n    return transforms;\n  }\n\n  return {\n    nullOr,\n    withDefault,\n    fromSnakeCaseKeys,\n  };\n}\n","/**\n * Determine if the passed value is an object.\n */\nexport function isObject(potentialObject: any): boolean {\n  return typeof potentialObject === 'object' && potentialObject !== null && !Array.isArray(potentialObject);\n}\n","import { Type } from '../types';\nimport { isObject } from './is-object';\n\nexport function deepFreeze<T extends Record<string, any>>(obj: T): Readonly<T> {\n  Object.keys(obj).forEach((prop) => {\n    if (isObject(obj[prop])) {\n      return deepFreeze(obj[prop]);\n    }\n  });\n\n  return Object.freeze(obj);\n}\n","import { Mutable } from '../types';\nimport { isObject } from './is-object';\n\n/**\n * Unfreeze an object.\n */\nexport function unfreeze<T extends Record<string, any>>(source: T): Mutable<T> {\n  let target: Record<string, any> = {};\n\n  for (const property in source) {\n    if (source.hasOwnProperty(property)) {\n      target[property] = isObject(source[property]) ? unfreeze(source[property]) : source[property];\n    }\n  }\n\n  Object.setPrototypeOf(target, Object.getPrototypeOf(source));\n\n  return target as T;\n}\n","import { Mutable, OptionalObject, WritablePart } from './types';\nimport { deepFreeze } from './utils/deep-freeze';\nimport { unfreeze } from './utils/unfreeze';\n\n/**\n * The models are technically immutable. Though you can technically mutate JS objects / models we want to try to\n * enforce immutability. This allows us to copy an object to a new object without modifying the original\n * object, hence, making it immutable.\n */\nexport function copyWith<T extends Record<string, any>>(\n  model: T,\n  values: OptionalObject<WritablePart<T>>,\n): Readonly<T> {\n  const m = Object.isFrozen(model) ? unfreeze(model) : model;\n  const clone = Object.create(Object.getPrototypeOf(m), Object.getOwnPropertyDescriptors(m));\n  const fields = {\n    ...clone,\n    ...values,\n  };\n\n  Object.keys(fields).forEach((key) => {\n    Object.defineProperty(clone, key, {\n      value: fields[key],\n    });\n  });\n\n  return deepFreeze(clone);\n}\n","import { TransformerDefinition } from './transform-api';\nimport { Type } from './types';\n\nconst transformMap = new Map<Type<any>, TransformerDefinition<any>>();\n\n/**\n * Define a transform method in the map.\n * This is a way for us to store a transform method for a given model\n * and later read it out when parsing from json.\n */\nexport function defineTransform<T>(Klass: Type<T>, transform: TransformerDefinition<T>): void {\n  transformMap.set(Klass, transform);\n}\n\n/**\n * Get the transform method for the given model.\n */\nexport function getTransform<T>(Klass: Type<T>): TransformerDefinition<T> | undefined {\n  return transformMap.get(Klass);\n}\n","import { createTransformAPI } from './transform-api';\nimport { getTransform } from './transform-map';\nimport { JsonResponse, Type } from './types';\nimport { deepFreeze } from './utils/deep-freeze';\nimport { isNullOrUndefined } from './utils/is-null-or-undefined';\n\n/**\n * Parse the passed json response into a the given model.\n */\nexport function fromJson<T extends Record<string, any>>(KlassName: Type<T>, json: JsonResponse): Readonly<T> {\n  const instance = new KlassName() as T;\n  const propertyKeys = Object.getOwnPropertyNames(instance);\n  const transformer = getTransform(KlassName);\n  const transform = transformer ? transformer(json, createTransformAPI(instance, json)) : {};\n\n  propertyKeys.forEach((k) => {\n    let value: any;\n\n    if (k in transform) {\n      value = transform[k];\n    } else {\n      value = isNullOrUndefined(json) ? null : json[k];\n    }\n\n    Object.defineProperty(instance, k, {\n      value,\n    });\n  });\n\n  return deepFreeze(instance);\n}\n","export function isNullOrUndefined(item: any): boolean {\n  return typeof item === 'undefined' || item === null;\n}\n","import { Mutable, OptionalObject, Type, WritablePart } from './types';\n\n/**\n * Create an instance of a model with all null keys\n * except for the values passed.\n */\nexport function nullable<T, Values extends OptionalObject<WritablePart<T>>>(\n  KlassName: Type<T>,\n  values?: Values,\n): Mutable<T> {\n  const instance = new KlassName() as T;\n  const propertyKeys = Object.getOwnPropertyNames(instance);\n\n  propertyKeys.forEach((k) => {\n    Object.defineProperty(instance, k, {\n      value: values && k in values ? values[k] : null,\n    });\n  });\n\n  return instance as Mutable<T & Values>;\n}\n","import { copyWith } from './copy-with';\nimport { Type, WritablePart } from './types';\n\n/**\n * Make an object by passing an object rather than the constructor\n * for better type inference.\n */\nexport function make<T>(Model: Type<T>, values: WritablePart<T>): Readonly<T> {\n  const instance = new Model() as T;\n\n  return copyWith(instance, values);\n}\n"],"names":["snakeCase","str","replace","split","map","word","toLowerCase","join","createTransformAPI","model","json","withDefault","nullable","transform","defaultVal","nullOr","fromSnakeCaseKeys","keys","transforms","forEach","key","Object","getOwnPropertyNames","potentialObject","Array","isArray","deepFreeze","obj","prop","isObject","freeze","unfreeze","source","target","hasOwnProperty","property","setPrototypeOf","getPrototypeOf","values","m","isFrozen","clone","create","getOwnPropertyDescriptors","fields","_extends","defineProperty","value","Map","defineTransform","Klass","transformMap","set","fromJson","KlassName","propertyKeys","instance","transformer","get","k","item","make","Model","copyWith"],"mappings":"AAAgBA,SAAAA,EAAUC,GACxB,OAAUA,EACPC,QAAQ,OAAQ,KAChBC,MAAM,iBACNC,IAAI,SAACC,GAASA,OAAAA,EAAKC,aAAa,GAChCC,KAAK,IACV,CC4CgBC,SAAAA,EAAsBC,EAAUC,GAK9C,SAAoBC,EAAOC,EAAyBC,EAAyBC,GAC3E,OAAIF,QACKE,EAGFD,GACT,CAoBA,MAAO,CACLE,OA/BF,SAAmBH,EAAyBC,GAC1C,OAAkBF,EAACC,EAAUC,EAAW,KAC1C,EA8BEF,YAAAA,EACAK,kBArBF,SAA8BC,GAC5B,IAAMC,EAAmC,CAAA,EAczC,OAZID,EACFA,EAAKE,QAAQ,SAACC,GACZF,EAAWE,GAAiBV,EAAKV,EAAUoB,GAC7C,GAEkBC,OAAOC,oBAAoBb,GAEnCU,QAAQ,SAACC,GACjBF,EAAWE,GAAiBV,EAAKV,EAAUoB,GAC7C,GAIJF,CAAA,EAOF,qOCnFM,WAAmBK,GACvB,MAAkC,iBAApBA,GAAoD,OAApBA,IAA6BC,MAAMC,QAAQF,EAC3F,UCF0BG,EAAgCC,GAOxD,OANAN,OAAOJ,KAAKU,GAAKR,QAAQ,SAACS,GACxB,GAAIC,EAASF,EAAIC,IACf,OAAOF,EAAWC,EAAIC,GAE1B,UAEcE,OAAOH,EACvB,CCLgBI,SAAAA,EAAwCC,GACtD,IAAUC,EAAwB,CAAA,EAElC,IAAK,SAAkBD,EACjBA,EAAOE,eAAeC,KACxBF,EAAOE,GAAYN,EAASG,EAAOG,IAAaJ,EAASC,EAAOG,IAAaH,EAAOG,IAMxF,OAFAd,OAAOe,eAAeH,EAAQZ,OAAOgB,eAAeL,IAGtDC,CAAA,CCTgB,WACdxB,EACA6B,GAEA,IAAMC,EAAIlB,OAAOmB,SAAS/B,GAASsB,EAAStB,GAASA,EAC/CgC,EAAQpB,OAAOqB,OAAOrB,OAAOgB,eAAeE,GAAIlB,OAAOsB,0BAA0BJ,IAC3EK,EAAAC,EAAA,CAAA,EACPJ,EACAH,GASL,OANAjB,OAAOJ,KAAK2B,GAAQzB,QAAQ,SAACC,GAC3BC,OAAOyB,eAAeL,EAAOrB,EAAK,CAChC2B,MAAOH,EAAOxB,IAElB,GAEOM,EAAWe,EACpB,CCxBA,MAAqB,IAAgDO,IAOrDC,SAAAA,EAAmBC,EAAgBrC,GACjDsC,EAAaC,IAAIF,EAAOrC,EAC1B,CCHgB,SAAQwC,EAAgCC,EAAoB5C,GAC1E,MAAiB,IAAoB4C,EAC/BC,EAAelC,OAAOC,oBAAoBkC,GAC1CC,EDMaN,EAACO,ICNaJ,GAClBzC,EAAG4C,EAAcA,EAAY/C,EAAMF,EAAmBgD,EAAU9C,IAAS,CAAA,EAgBxF,OAdA6C,EAAapC,QAAQ,SAACwC,GASpBtC,OAAOyB,eAAeU,EAAUG,EAAG,CACjCZ,MAPEY,KAAK9C,EACCA,EAAU8C,GClBRC,MDoBgBlD,EAAQ,KAAOA,EAAKiD,IAMlD,GAEiBjC,EAAC8B,EACpB,CExBgB5C,SAAAA,EACd0C,EACAhB,GAEA,IAAMkB,EAAW,IAAoBF,EASrC,OARqBjC,OAAOC,oBAAoBkC,GAEnCrC,QAAQ,SAACwC,GACpBtC,OAAOyB,eAAeU,EAAUG,EAAG,CACjCZ,MAAOT,GAAUqB,KAAKrB,EAASA,EAAOqB,GAAK,MAE/C,GAGFH,CAAA,UCboBK,EAAIC,EAAgBxB,GAGtC,OAAOyB,EAFU,IAAgBD,EAEPxB,EAC5B"}