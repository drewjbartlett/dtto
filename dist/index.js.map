{"version":3,"file":"index.js","sources":["../src/utils/snake-case.ts","../src/transform-api.ts","../src/copy-with.ts","../src/transform-map.ts","../src/from-json.ts","../src/utils/is-null-or-undefined.ts","../src/mutable.ts","../src/make.ts"],"sourcesContent":["export function snakeCase(str: string): string {\n  return str\n    .replace(/\\W+/g, ' ')\n    .split(/ |\\B(?=[A-Z])/)\n    .map((word) => word.toLowerCase())\n    .join('_');\n}\n","import { AllowableKeys, fromJson, JsonResponse, Type } from '.';\nimport { getTransform } from './transform-map';\nimport { Nullable } from './types';\nimport { snakeCase } from './utils/snake-case';\n\nexport type TransformResponse<T> = {\n  [k in AllowableKeys<T>]?: T[k];\n};\n\nexport type Transform<T> = () => T;\n\nexport type TransformerDefinition<T> = (json: JsonResponse, api: TransformAPI) => TransformResponse<T>;\n\nexport interface TransformAPI {\n  /**\n   * Allows for returning null if the value is set to null. Otherwise the the transform method is invoked\n   * and the value is returned.\n   */\n  nullOr: <T>(nullable: Nullable<any>, transform: Transform<T>) => Nullable<T>;\n\n  /**\n   * Allows for returning a default value if the given value is set to null. Otherwise the the transform method is invoked\n   * and the value return from that is returned.\n   */\n  withDefault: <T, D>(nullable: Nullable<any>, transform: Transform<T>, defaultVal: D) => T | D;\n\n  /**\n   * Allows for multiple keys to be passed an converted from whatever casing to snake_case.\n   * This is useful when many of your attributes are returned in something like snake_case.\n   * If keys is omitted, all keys will be read from snake_case json values.\n   *\n   * This is shorthand for doing:\n   *\n   * ```\n   * return {\n   *    userId: json.user_id,\n   *    firstName: json.first_name,\n   *    lastName: json.last_name,\n   * }\n   * ```\n   */\n  fromSnakeCaseKeys<T>(keys?: AllowableKeys<T>[]): TransformResponse<T>;\n}\n\nlet calls = 0;\n\n/**\n * The factory method to create the transform API.\n * This uses currying so we can leverage the current model as part of the context.\n */\nexport function createTransformAPI<T>(model: T, json: JsonResponse): TransformAPI {\n  function nullOr<T>(nullable: Nullable<any>, transform: Transform<T>): Nullable<T> {\n    return withDefault(nullable, transform, null);\n  }\n\n  function withDefault<T, D>(nullable: Nullable<any>, transform: Transform<T>, defaultVal: D): T | D {\n    if (nullable === null || typeof nullable === 'undefined') {\n      return defaultVal;\n    }\n\n    return transform();\n  }\n\n  function fromSnakeCaseKeys<T>(keys?: AllowableKeys<T>[]): TransformResponse<T> {\n    const transforms: TransformResponse<T> = {};\n\n    if (keys) {\n      keys.forEach((key) => {\n        transforms[key as string] = json[snakeCase(key as string)];\n      });\n    } else {\n      const modelKeys = Object.getOwnPropertyNames(model);\n\n      modelKeys.forEach((key) => {\n        transforms[key as string] = json[snakeCase(key as string)];\n      });\n    }\n\n    return transforms;\n  }\n\n  return {\n    nullOr,\n    withDefault,\n    fromSnakeCaseKeys,\n  };\n}\n","import { TransformResponse } from './transform-api';\nimport { OptionalObject, WritablePart } from './types';\n\n/**\n * The models are technically immutable. Though you can technically mutate JS objects / models we want to try to\n * enforce immutability. This allows us to copy an object to a new object without modifying the original\n * object, hence, making it immutable.\n */\nexport function copyWith<T>(model: T, values: OptionalObject<WritablePart<T>>): T {\n  const clone = Object.create(Object.getPrototypeOf(model), Object.getOwnPropertyDescriptors(model));\n  const fields = {\n    ...clone,\n    ...values,\n  };\n\n  Object.keys(fields).forEach((key) => {\n    Object.defineProperty(clone, key, {\n      value: fields[key],\n    });\n  });\n\n  return clone;\n}\n","import { TransformerDefinition } from './transform-api';\nimport { Type } from './types';\n\nconst transformMap = new Map<Type<any>, TransformerDefinition<any>>();\n\n/**\n * Define a transform method in the map.\n * This is a way for us to store a transform method for a given model\n * and later read it out when parsing from json.\n */\nexport function defineTransform<T>(Klass: Type<T>, transform: TransformerDefinition<T>): void {\n  transformMap.set(Klass, transform);\n}\n\n/**\n * Get the transform method for the given model.\n */\nexport function getTransform<T>(Klass: Type<T>): TransformerDefinition<T> | undefined {\n  return transformMap.get(Klass);\n}\n","import { createTransformAPI, JsonResponse, Type } from '.';\nimport { getTransform } from './transform-map';\nimport { isNullOrUndefined } from './utils/is-null-or-undefined';\n\n/**\n * Parse the passed json response into a the given model.\n */\nexport function fromJson<T>(KlassName: Type<T>, json: JsonResponse): T {\n  const instance = new KlassName() as T;\n  const propertyKeys = Object.getOwnPropertyNames(instance);\n  const transformer = getTransform(KlassName);\n  const transform = transformer ? transformer(json, createTransformAPI(instance, json)) : {};\n\n  propertyKeys.forEach((k) => {\n    let value: any;\n\n    if (k in transform) {\n      value = transform[k];\n    } else {\n      value = isNullOrUndefined(json) ? null : json[k];\n    }\n\n    Object.defineProperty(instance, k, {\n      value,\n      writable: true,\n    });\n  });\n\n  return instance as T;\n}\n","export function isNullOrUndefined(item: any): boolean {\n  return typeof item === 'undefined' || item === null;\n}\n","import { Mutable, OptionalObject, Type, WritablePart } from './types';\n\n/**\n * Create an instance of a model with all null keys.\n */\nexport function mutable<T, Values extends OptionalObject<WritablePart<T>>>(\n  KlassName: Type<T>,\n  values?: Values,\n): Mutable<T> {\n  const instance = new KlassName() as T;\n  const propertyKeys = Object.getOwnPropertyNames(instance);\n\n  propertyKeys.forEach((k) => {\n    Object.defineProperty(instance, k, {\n      value: values && k in values ? values[k] : null,\n    });\n  });\n\n  return instance as Mutable<T & Values>;\n}\n","import { copyWith } from './copy-with';\nimport { Type, WritablePart } from './types';\n\n/**\n * Make an object by passing an object rather than the constructor\n * for better type inference.\n */\nexport function make<T>(Model: Type<T>, values: WritablePart<T>): T {\n  const instance = new Model() as T;\n\n  return copyWith(instance, values);\n}\n"],"names":["snakeCase","str","replace","split","map","word","toLowerCase","join","createTransformAPI","model","json","withDefault","nullable","transform","defaultVal","nullOr","fromSnakeCaseKeys","keys","transforms","forEach","key","Object","getOwnPropertyNames","copyWith","values","create","getPrototypeOf","getOwnPropertyDescriptors","fields","_extends","clone","defineProperty","value","Map","defineTransform","Klass","transformMap","set","fromJson","KlassName","instance","propertyKeys","transformer","get","k","item","writable","mutable","make","Model"],"mappings":"AAAgBA,SAAAA,EAAUC,GACxB,OAAUA,EACPC,QAAQ,OAAQ,KAChBC,MAAM,iBACNC,IAAI,SAACC,GAASA,OAAAA,EAAKC,aAAa,GAChCC,KAAK,IACV,CC4CgBC,SAAAA,EAAsBC,EAAUC,GAK9C,SAAoBC,EAAOC,EAAyBC,EAAyBC,GAC3E,OAAIF,QACKE,EAGFD,GACT,CAoBA,MAAO,CACLE,OA/BF,SAAmBH,EAAyBC,GAC1C,OAAkBF,EAACC,EAAUC,EAAW,KAC1C,EA8BEF,YAAAA,EACAK,kBArBF,SAA8BC,GAC5B,IAAMC,EAAmC,CAAA,EAczC,OAZID,EACFA,EAAKE,QAAQ,SAACC,GACZF,EAAWE,GAAiBV,EAAKV,EAAUoB,GAC7C,GAEkBC,OAAOC,oBAAoBb,GAEnCU,QAAQ,SAACC,GACjBF,EAAWE,GAAiBV,EAAKV,EAAUoB,GAC7C,GAIJF,CAAA,EAOF,qOC9EgBK,SAAAA,EAAYd,EAAUe,GACpC,MAAcH,OAAOI,OAAOJ,OAAOK,eAAejB,GAAQY,OAAOM,0BAA0BlB,IAC/EmB,EAAAC,EAAA,GACPC,EACAN,GASL,OANAH,OAAOJ,KAAKW,GAAQT,QAAQ,SAACC,GAC3BC,OAAOU,eAAeD,EAAOV,EAAK,CAChCY,MAAOJ,EAAOR,IAElB,GAGFU,CAAA,CCnBA,MAAqB,IAAgDG,IAOrDC,SAAAA,EAAmBC,EAAgBtB,GACjDuB,EAAaC,IAAIF,EAAOtB,EAC1B,CCLgB,SAAQyB,EAAIC,EAAoB7B,GAC9C,IAAc8B,EAAG,IAAID,EACfE,EAAepB,OAAOC,oBAAoBkB,GAC1CE,EDQaN,EAACO,ICRaJ,GAC3B1B,EAAY6B,EAAcA,EAAYhC,EAAMF,EAAmBgC,EAAU9B,IAAS,CAAE,EAiB1F,OAfA+B,EAAatB,QAAQ,SAACyB,GASpBvB,OAAOU,eAAeS,EAAUI,EAAG,CACjCZ,MAPEY,KAAK/B,EACCA,EAAU+B,GChBRC,MDkBgBnC,EAAQ,KAAOA,EAAKkC,GAK9CE,UAAU,GAEd,GAGFN,CAAA,CExBgBO,SAAAA,EACdR,EACAf,GAEA,IAAMgB,EAAW,IAAoBD,EASrC,OARqBlB,OAAOC,oBAAoBkB,GAEnCrB,QAAQ,SAACyB,GACpBvB,OAAOU,eAAeS,EAAUI,EAAG,CACjCZ,MAAOR,GAAUoB,KAAKpB,EAASA,EAAOoB,GAAK,MAE/C,GAGFJ,CAAA,UCZoBQ,EAAIC,EAAgBzB,GAGtC,OAAOD,EAFU,IAAgB0B,EAEPzB,EAC5B"}