{"version":3,"file":"index.modern.js","sources":["../src/utils/snake-case.ts","../src/transform-api.ts","../src/copy-with.ts","../src/transform-map.ts","../src/from-json.ts","../src/utils/is-null-or-undefined.ts","../src/mutable.ts","../src/make.ts"],"sourcesContent":["export function snakeCase(str: string): string {\n  return str\n    .replace(/\\W+/g, ' ')\n    .split(/ |\\B(?=[A-Z])/)\n    .map((word) => word.toLowerCase())\n    .join('_');\n}\n","import { AllowableKeys, fromJson, JsonResponse, Type } from '.';\nimport { getTransform } from './transform-map';\nimport { Nullable } from './types';\nimport { snakeCase } from './utils/snake-case';\n\nexport type TransformResponse<T> = {\n  [k in AllowableKeys<T>]?: T[k];\n};\n\nexport type Transform<T> = () => T;\n\nexport type TransformerDefinition<T> = (json: JsonResponse, api: TransformAPI) => TransformResponse<T>;\n\nexport interface TransformAPI {\n  /**\n   * Allows for returning null if the value is set to null. Otherwise the the transform method is invoked\n   * and the value is returned.\n   */\n  nullOr: <T>(nullable: Nullable<any>, transform: Transform<T>) => Nullable<T>;\n\n  /**\n   * Allows for returning a default value if the given value is set to null. Otherwise the the transform method is invoked\n   * and the value return from that is returned.\n   */\n  withDefault: <T, D>(nullable: Nullable<any>, transform: Transform<T>, defaultVal: D) => T | D;\n\n  /**\n   * Allows for multiple keys to be passed an converted from whatever casing to snake_case.\n   * This is useful when many of your attributes are returned in something like snake_case.\n   * If keys is omitted, all keys will be read from snake_case json values.\n   *\n   * This is shorthand for doing:\n   *\n   * ```\n   * return {\n   *    userId: json.user_id,\n   *    firstName: json.first_name,\n   *    lastName: json.last_name,\n   * }\n   * ```\n   */\n  fromSnakeCaseKeys<T>(keys?: AllowableKeys<T>[]): TransformResponse<T>;\n}\n\nlet calls = 0;\n\n/**\n * The factory method to create the transform API.\n * This uses currying so we can leverage the current model as part of the context.\n */\nexport function createTransformAPI<T>(model: T, json: JsonResponse): TransformAPI {\n  function nullOr<T>(nullable: Nullable<any>, transform: Transform<T>): Nullable<T> {\n    return withDefault(nullable, transform, null);\n  }\n\n  function withDefault<T, D>(nullable: Nullable<any>, transform: Transform<T>, defaultVal: D): T | D {\n    if (nullable === null || typeof nullable === 'undefined') {\n      return defaultVal;\n    }\n\n    return transform();\n  }\n\n  function fromSnakeCaseKeys<T>(keys?: AllowableKeys<T>[]): TransformResponse<T> {\n    const transforms: TransformResponse<T> = {};\n\n    if (keys) {\n      keys.forEach((key) => {\n        transforms[key as string] = json[snakeCase(key as string)];\n      });\n    } else {\n      const modelKeys = Object.getOwnPropertyNames(model);\n\n      modelKeys.forEach((key) => {\n        transforms[key as string] = json[snakeCase(key as string)];\n      });\n    }\n\n    return transforms;\n  }\n\n  return {\n    nullOr,\n    withDefault,\n    fromSnakeCaseKeys,\n  };\n}\n","import { TransformResponse } from './transform-api';\nimport { OptionalObject, WritablePart } from './types';\n\n/**\n * The models are technically immutable. Though you can technically mutate JS objects / models we want to try to\n * enforce immutability. This allows us to copy an object to a new object without modifying the original\n * object, hence, making it immutable.\n */\nexport function copyWith<T>(model: T, values: OptionalObject<WritablePart<T>>): T {\n  const clone = Object.create(Object.getPrototypeOf(model), Object.getOwnPropertyDescriptors(model));\n  const fields = {\n    ...clone,\n    ...values,\n  };\n\n  Object.keys(fields).forEach((key) => {\n    Object.defineProperty(clone, key, {\n      value: fields[key],\n    });\n  });\n\n  return clone;\n}\n","import { TransformerDefinition } from './transform-api';\nimport { Type } from './types';\n\nconst transformMap = new Map<Type<any>, TransformerDefinition<any>>();\n\n/**\n * Define a transform method in the map.\n * This is a way for us to store a transform method for a given model\n * and later read it out when parsing from json.\n */\nexport function defineTransform<T>(Klass: Type<T>, transform: TransformerDefinition<T>): void {\n  transformMap.set(Klass, transform);\n}\n\n/**\n * Get the transform method for the given model.\n */\nexport function getTransform<T>(Klass: Type<T>): TransformerDefinition<T> | undefined {\n  return transformMap.get(Klass);\n}\n","import { createTransformAPI, JsonResponse, Type } from '.';\nimport { getTransform } from './transform-map';\nimport { isNullOrUndefined } from './utils/is-null-or-undefined';\n\n/**\n * Parse the passed json response into a the given model.\n */\nexport function fromJson<T>(KlassName: Type<T>, json: JsonResponse): T {\n  const instance = new KlassName() as T;\n  const propertyKeys = Object.getOwnPropertyNames(instance);\n  const transformer = getTransform(KlassName);\n  const transform = transformer ? transformer(json, createTransformAPI(instance, json)) : {};\n\n  propertyKeys.forEach((k) => {\n    let value: any;\n\n    if (k in transform) {\n      value = transform[k];\n    } else {\n      value = isNullOrUndefined(json) ? null : json[k];\n    }\n\n    Object.defineProperty(instance, k, {\n      value,\n      writable: true,\n    });\n  });\n\n  return instance as T;\n}\n","export function isNullOrUndefined(item: any): boolean {\n  return typeof item === 'undefined' || item === null;\n}\n","import { Mutable, OptionalObject, Type, WritablePart } from './types';\n\n/**\n * Create an instance of a model with all null keys.\n */\nexport function mutable<T, Values extends OptionalObject<WritablePart<T>>>(\n  KlassName: Type<T>,\n  values?: Values,\n): Mutable<T> {\n  const instance = new KlassName() as T;\n  const propertyKeys = Object.getOwnPropertyNames(instance);\n\n  propertyKeys.forEach((k) => {\n    Object.defineProperty(instance, k, {\n      value: values && k in values ? values[k] : null,\n    });\n  });\n\n  return instance as Mutable<T & Values>;\n}\n","import { copyWith } from './copy-with';\nimport { Type, WritablePart } from './types';\n\n/**\n * Make an object by passing an object rather than the constructor\n * for better type inference.\n */\nexport function make<T>(Model: Type<T>, values: WritablePart<T>): T {\n  const instance = new Model() as T;\n\n  return copyWith(instance, values);\n}\n"],"names":["snakeCase","str","replace","split","map","word","toLowerCase","join","createTransformAPI","model","json","withDefault","nullable","transform","defaultVal","nullOr","fromSnakeCaseKeys","keys","transforms","forEach","key","Object","getOwnPropertyNames","copyWith","values","clone","create","getPrototypeOf","getOwnPropertyDescriptors","fields","defineProperty","value","Map","defineTransform","Klass","transformMap","set","fromJson","KlassName","instance","propertyKeys","transformer","get","k","item","writable","mutable","make","Model"],"mappings":"AAAgBA,SAAAA,EAAUC,GACxB,OAAUA,EACPC,QAAQ,OAAQ,KAChBC,MAAM,iBACNC,IAAKC,GAASA,EAAKC,eACnBC,KAAK,IACV,CC4CgB,SAAkBC,EAAIC,EAAUC,GAK9C,SAAoBC,EAAOC,EAAyBC,EAAyBC,GAC3E,OAAIF,QAEHE,EAEeD,GAClB,CAoBA,MAAO,CACLE,OA/BF,SAAmBH,EAAyBC,GAC1C,SAAmBD,EAAUC,EAAW,KAC1C,EA8BEF,cACAK,kBArBF,SAA8BC,GAC5B,MAAgBC,EAAyB,CAAE,EAc3C,OAZID,EACFA,EAAKE,QAASC,IACZF,EAAWE,GAAiBV,EAAKV,EAAUoB,GAC7C,GAEkBC,OAAOC,oBAAoBb,GAEnCU,QAASC,IACjBF,EAAWE,GAAiBV,EAAKV,EAAUoB,GAC7C,GAGKF,CACT,EAOF,qOC9EgBK,SAAAA,EAAYd,EAAUe,GACpC,MAAWC,EAAGJ,OAAOK,OAAOL,OAAOM,eAAelB,GAAQY,OAAOO,0BAA0BnB,IACrFoB,OACDJ,EACAD,GASL,OANAH,OAAOJ,KAAKY,GAAQV,QAASC,IAC3BC,OAAOS,eAAeL,EAAOL,EAAK,CAChCW,MAAOF,EAAOT,IAElB,GAGFK,CAAA,CCnBA,QAAqB,IAAgDO,IAOrDC,SAAAA,EAAmBC,EAAgBrB,GACjDsB,EAAaC,IAAIF,EAAOrB,EAC1B,CCLgB,SAAQwB,EAAIC,EAAoB5B,GAC9C,MAAc6B,EAAG,IAAID,EACHE,EAAGnB,OAAOC,oBAAoBiB,GAC/BE,EDQEN,EAACO,ICRaJ,GAClBzB,EAAG4B,EAAcA,EAAY/B,EAAMF,EAAmB+B,EAAU7B,IAAS,CAAE,EAiB1F,OAfA8B,EAAarB,QAASwB,IACpB,IAAcZ,EAGZA,EADEY,KAAK9B,EACCA,EAAU8B,GChBRC,MDkBgBlC,EAAQ,KAAOA,EAAKiC,GAGhDtB,OAAOS,eAAeS,EAAUI,EAAG,CACjCZ,QACAc,UAAU,GACX,GAILN,CAAA,CExBgBO,SAAAA,EACdR,EACAd,GAEA,MAAMe,EAAW,IAAoBD,EASrC,OARqBjB,OAAOC,oBAAoBiB,GAEnCpB,QAASwB,IACpBtB,OAAOS,eAAeS,EAAUI,EAAG,CACjCZ,MAAOP,GAAUmB,KAAWnB,EAAGA,EAAOmB,GAAK,MAC5C,GAILJ,CAAA,UCZoBQ,EAAIC,EAAgBxB,GAGtC,OAAOD,EAFU,IAAgByB,EAEPxB,EAC5B"}